#!/usr/bin/env bash

# This code was written by AI, and of course it doesn't work as it should.
# The main functionality works, but for example, when you select to change your password, 
# it immediately takes you back to the menu. I don't know why it's here. 

source "$VIBRANIUM_PATH/vibranium-core-lib"

if ! command -v pass >/dev/null; then
	msg="'<span foreground='${P_YELLOW}'><b>pass</b></span>' is not installed!\n\n"
	msg+="<b>Click here to isntall</b>"
	if [ "$(notify-send -A true -r 4 -t 5000 "Vibranium" "$msg")" = "0" ]; then
		vibranium-cmd-launch-terminal sudo pacman -S --noconfirm pass
	else
		exit 1
	fi
fi

# Global array to store the last selected row for each menu context
declare -A last_selected_row

# Set default PASSWORD_STORE_DIR if not set
if [[ -z "$PASSWORD_STORE_DIR" ]]; then
    if [[ -n "$XDG_DATA_HOME" ]]; then
        PASSWORD_STORE_DIR="$XDG_DATA_HOME/password-store"
    else
        PASSWORD_STORE_DIR="$HOME/.local/share/password-store"
    fi
    export PASSWORD_STORE_DIR
fi

# Check if password store is initialized
is_password_store_initialized() {
    [[ -d "$PASSWORD_STORE_DIR" ]] && [[ -f "$PASSWORD_STORE_DIR/.gpg-id" ]] && [[ -r "$PASSWORD_STORE_DIR/.gpg-id" ]]
}

# Check if git repo exists
is_git_repo() {
    [[ -d "$PASSWORD_STORE_DIR/.git" ]]
}

# Check if git repo has a remote named 'origin'
has_git_remote() {
    git -C "$PASSWORD_STORE_DIR" remote get-url origin >/dev/null 2>&1
}

# Check if password store has any entries
has_password_entries() {
    find "$PASSWORD_STORE_DIR" -type f -name "*.gpg" ! -path "$PASSWORD_STORE_DIR/.git/*" 2>/dev/null | grep -q .
}

# Helper function to push, setting upstream if it's the first time
git_push_with_upstream_check() {
    if ! has_git_remote; then
        echo "Error: No remote repository named 'origin' configured."
        return 1
    fi

    local current_branch
    current_branch=$(git -C "$PASSWORD_STORE_DIR" rev-parse --abbrev-ref HEAD)

    if ! pass git rev-parse --verify --quiet "@{u}" >/dev/null; then
        pass git push -u origin "$current_branch"
    else
        pass git push
    fi
}

# Tries to get a valid git URL from the clipboard
get_git_url_from_clipboard() {
    local clipboard_content
    clipboard_content="$(wl-paste)"

    if [[ -z "$clipboard_content" || ! "$clipboard_content" =~ \.git$ ]]; then
        return 1
    fi

    local regex='^((https?://|git@)(github\.com|codeberg\.org|gitlab\.com|gitlab\.[a-zA-Z0-9.-]+)(/|:)).*\.git$'

    if [[ "$clipboard_content" =~ $regex ]]; then
        printf "%s" "$clipboard_content"
        return 0
    fi

    return 1
}

pick_location() {
    local current_path="${1:-}"
    local mode="${2:-generate}"
    local full_dir
    local dirs
    local items
    local chosen
    local type
    local name
    local new_folder
    local dummy="Enter folder name"
    local action_text

    if [[ "$mode" == "move" ]]; then
        action_text="[M] Move file here"
    else
        action_text="[P] Generate password here"
    fi

    while true; do
        local row_key="location:$current_path:$mode"
        full_dir="$PASSWORD_STORE_DIR/$current_path"
        mapfile -t dirs < <(find "$full_dir" -mindepth 1 -maxdepth 1 -type d ! -name ".git" -printf "%f\n" | sort -V)
        items=("$action_text" "[C] Create new folder")
        for d in "${dirs[@]}"; do
            items+=("[D] $d")
        done

        local selected_row="${last_selected_row[$row_key]:-0}"
        chosen="$(printf "%s\n" "${items[@]}" | rofi_cmd "Choose location: /$current_path" "" -selected-row "$selected_row")"
        if [[ -z "$chosen" ]]; then
            if [[ -z "$current_path" ]]; then
                return 1
            fi
            if [[ $current_path == */* ]]; then
                current_path="${current_path%/*}"
            else
                current_path=""
            fi
            continue
        fi

        if [[ "$chosen" == "$action_text" ]]; then
            for i in "${!items[@]}"; do
                if [[ "${items[$i]}" == "$chosen" ]]; then
                    last_selected_row[$row_key]="$i"
                    break
                fi
            done
            printf "%s" "$current_path"
            return 0
        elif [[ "$chosen" == "[C] Create new folder" ]]; then
            for i in "${!items[@]}"; do
                if [[ "${items[$i]}" == "$chosen" ]]; then
                    last_selected_row[$row_key]="$i"
                    break
                fi
            done
            
            new_folder="$(printf "%s\n" "$dummy" | rofi_cmd "New folder name" "$dummy")"
            if [[ "$new_folder" == "$dummy" ]] || [[ -z "$new_folder" ]]; then
                continue
            fi
            if mkdir -p "$full_dir/$new_folder"; then
                notify-send -r 1 -t 1500 -u low "Vibranium" "Folder created"
            else
                notify-send -r 1 -t 1500 -u low "Vibranium" "Error creating folder"
            fi
            continue
        else
            type="${chosen:1:1}"
            name="${chosen#\["${type}"\] }"
            if [[ "$type" == "D" ]]; then
                for i in "${!items[@]}"; do
                    if [[ "${items[$i]}" == "$chosen" ]]; then
                        last_selected_row[$row_key]="$i"
                        break
                    fi
                done
                
                if [[ -z "$current_path" ]]; then
                    current_path="$name"
                else
                    current_path="$current_path/$name"
                fi
                continue
            fi
        fi
    done
}

pick_password_path() {
    local current_path="${1:-}"
    local full_dir
    local dirs
    local files
    local items
    local chosen
    local type
    local name

    while true; do
        local row_key="password_path:$current_path"
        full_dir="$PASSWORD_STORE_DIR/$current_path"
        mapfile -t dirs < <(find "$full_dir" -mindepth 1 -maxdepth 1 -type d ! -name ".git" -printf "%f\n" | sort -V)
        mapfile -t files < <(find "$full_dir" -maxdepth 1 -type f -name "*.gpg" -printf "%f\n" | sed 's/\.gpg$//' | sort -V)
        items=()
        for d in "${dirs[@]}"; do
            items+=("[D] $d")
        done
        for f in "${files[@]}"; do
            items+=("[F] $f")
        done

        if [[ ${#items[@]} -eq 0 ]]; then
            if [[ -z "$current_path" ]]; then
                return 1
            fi
            if [[ $current_path == */* ]]; then
                current_path="${current_path%/*}"
            else
                current_path=""
            fi
            continue
        fi

        local selected_row="${last_selected_row[$row_key]:-0}"
        chosen="$(printf "%s\n" "${items[@]}" | rofi_cmd "> /$current_path" "" -selected-row "$selected_row")"
        if [[ -z "$chosen" ]]; then
            if [[ -z "$current_path" ]]; then
                return 1
            fi
            if [[ $current_path == */* ]]; then
                current_path="${current_path%/*}"
            else
                current_path=""
            fi
            continue
        fi

        # Save the selected index for both files and directories
        for i in "${!items[@]}"; do
            if [[ "${items[$i]}" == "$chosen" ]]; then
                last_selected_row[$row_key]="$i"
                break
            fi
        done

        type="${chosen:1:1}"
        name="${chosen#\["${type}"\] }"
        
        if [[ "$type" == "D" ]]; then
            if [[ -z "$current_path" ]]; then
                current_path="$name"
            else
                current_path="$current_path/$name"
            fi
            continue
        elif [[ "$type" == "F" ]]; then
            local password_full
            if [[ -z "$current_path" ]]; then
                password_full="$name"
            else
                password_full="$current_path/$name"
            fi
            
            # Call action menu and handle the result
            while true; do
                action "$password_full"
                action_ret=$?
                if [[ $action_ret -eq 0 ]]; then
                    return 0  # Exit completely
                elif [[ $action_ret -eq 2 ]]; then
                    break  # Back to file list in the same directory
                elif [[ $action_ret -eq 3 ]]; then
                    # After delete, check if directory still exists
                    full_dir="$PASSWORD_STORE_DIR/$current_path"
                    while [[ -n "$current_path" ]] && [[ ! -d "$full_dir" ]]; do
                        if [[ $current_path == */* ]]; then
                            current_path="${current_path%/*}"
                        else
                            current_path=""
                        fi
                        full_dir="$PASSWORD_STORE_DIR/$current_path"
                    done
                    break  # Back to file list in parent directory
                else
                    continue  # Stay in action menu
                fi
            done
            continue  # Continue the main loop to show the file list again
        fi
    done
}

escape_for_shell_arg() {
    local s="$1"
    s="${s//\'/\'\\\'\'}"
    printf "%s" "$s"
}

action() {
    local password="$1"
    local actions=("Copy" "View" "Edit" "Move" "Rename" "Delete")
    local action_chosen
    local confirm
    local new_name
    local dummy="Enter new name"
    local parent
    if [[ $password == */* ]]; then
        parent="${password%/*}"
    else
        parent=""
    fi
    local new_path
    local password_content
    local safe_password
    safe_password="$(escape_for_shell_arg "$password")"
    local row_key="action:$password"

    while true; do
        local selected_row="${last_selected_row[$row_key]:-0}"
        action_chosen="$(printf "%s\n" "${actions[@]}" | rofi_cmd "Action for $password" "" -selected-row "$selected_row")"
        [[ -z "$action_chosen" ]] && return 2
        [[ " ${actions[*]} " == *" $action_chosen "* ]] && break

        for i in "${!actions[@]}"; do
            if [[ "${actions[$i]}" == "$action_chosen" ]]; then
                last_selected_row[$row_key]="$i"
                break
            fi
        done
    done

    case "$action_chosen" in
        "Copy")
            if pass -c "$password" >/dev/null; then
                notify-send -r 1 -u low "Vibranium" "Password copied to clipboard\nIt will be cleared after 45 seconds"
                return 0
            else
                notify-send -r 1 -t 1500 -u low "Vibranium" "Error copying password"
                return 1
            fi
            ;;
        "View")
            password_content="$(pass show ""''"$password"''"")" || {
                notify-send -r 2 -t 5000 -u critical "Vibranium" "Error viewing password"
                return 1
            }
            notify-send -r 1 "Vibranium" "$password_content"
            return 2
            ;;
        "Edit")
            $VIBRANIUM_DEFAULT_TERMINAL -e pass edit "$password"
            local edit_ret=$?

            if [[ $edit_ret -eq 1 ]]; then
                return 1
            elif [[ $edit_ret -eq 0 ]]; then
                notify-send -r 1 -t 1500 -u low "Vibranium" "Password successfully edited"
                
                if is_git_repo; then
                    output="$(git_push_with_upstream_check 2>&1)"; push_ret=$?
                    if [[ $push_ret -ne 0 ]]; then
                        notify-send -r 2 -t 5000 -u critical "Vibranium" "Error pushing to remote: $output"
                    else
                        notify-send -r 1 -t 2000 -u low "Vibranium" "Pushed to remote"
                    fi
                fi
                return 2
            else
                return 1
            fi
            ;;
        "Move")
            local target_location
            target_location="$(pick_location "" "move")" || return 1
            
            local filename="${password##*/}"
            if [[ -z "$target_location" ]]; then
                new_path="$filename"
            else
                new_path="$target_location/$filename"
            fi
            
            if [[ "$new_path" == "$password" ]]; then
                notify-send -r 1 -t 1500 -u low "Vibranium" "Same location, nothing to move"
                return 1
            fi
            
            local safe_new_path
            safe_new_path="$(escape_for_shell_arg "$new_path")"
            if pass mv "$safe_password" "$safe_new_path" >/dev/null; then
                notify-send -r 1 -t 1500 -u low "Vibranium" "Password moved"
                if is_git_repo; then
                    (
                        output="$(git_push_with_upstream_check 2>&1)"; push_ret=$?
                        if [[ $push_ret -ne 0 ]]; then
                            notify-send -r 2 -t 5000 -u critical "Vibranium" "Error pushing to remote: $output"
                        else
                            notify-send -r 1 -t 2000 -u low "Vibranium" "Pushed to remote"
                        fi
                    ) &
                fi
                return 2
            else
                return 1
            fi
            ;;
        "Rename")
            new_name="$(printf "%s\n" "$dummy" | rofi_cmd "New name for $password" "$dummy")"
            if [[ "$new_name" == "$dummy" ]] || [[ -z "$new_name" ]]; then
                return 1
            fi
            if [[ -z "$parent" ]]; then
                new_path="$new_name"
            else
                new_path="$parent/$new_name"
            fi
            local safe_new_path
            safe_new_path="$(escape_for_shell_arg "$new_path")"
            if pass mv "$safe_password" "$safe_new_path" >/dev/null; then
                notify-send -r 1 -t 1500 -u low "Vibranium" "Password renamed"
                if is_git_repo; then
                    (
                        output="$(git_push_with_upstream_check 2>&1)"; push_ret=$?
                        if [[ $push_ret -ne 0 ]]; then
                            notify-send -r 2 -t 5000 -u critical "Vibranium" "Error pushing to remote: $output"
                        else
                            notify-send -r 1 -t 2000 -u low "Vibranium" "Pushed to remote"
                        fi
                    ) &
                fi
                return 2
            else
                return 1
            fi
            ;;
        "Delete")
            confirm="$(printf "Yes\nNo\n" | rofi_cmd "Delete $password?" "")"
            if [[ "$confirm" != "Yes" ]]; then
                return 1
            fi
            if pass rm --force "$safe_password" >/dev/null; then
                notify-send -r 1 -t 1500 -u low "Vibranium" "Password deleted"
                if is_git_repo; then
                    (
                        output="$(git_push_with_upstream_check 2>&1)"; push_ret=$?
                        if [[ $push_ret -ne 0 ]]; then
                            notify-send -r 1 -t 1500 -u low "Vibranium" "Error pushing to remote: $output"
                        else
                            notify-send -r 1 -t 1500 -u low "Vibranium" "Pushed to remote"
                        fi
                    ) &
                fi
                return 3
            else
                return 1
            fi
            ;;
    esac
}

initialize_password_store() {
    mapfile -t gpg_ids < <(gpg --list-secret-keys --with-colons 2>/dev/null | awk -F: '$1 == "sec" {print $5}')
    
    if [[ ${#gpg_ids[@]} -eq 0 ]]; then
        notify-send -r 2 -t 5000 -u critical "Vibranium" "No GPG keys found. Please create one first with gpg --gen-key"
        return 1
    fi
    
    local selected_key_id="${gpg_ids[0]}"
    
    mkdir -p "$PASSWORD_STORE_DIR" || {
        notify-send -r 2 -t 5000 -u critical "Vibranium" "Error creating password store directory"
        return 1
    }
    
    if pass init "$selected_key_id" >/dev/null 2>&1; then
        notify-send -r 1 -t 2000 -u low "Vibranium" "Password store initialized successfully"
        return 0
    else
        notify-send -r 2 -t 5000 -u critical "Vibranium" "Error initializing password store"
        return 1
    fi
}

add_git_remote() {
    local remote_url
    remote_url="$(get_git_url_from_clipboard)"

    if [[ -n "$remote_url" ]]; then
        notify-send -r 1 -t 3000 -u normal "Vibranium" "Using URL from clipboard: $remote_url"
    else
        local dummy="e.g. git@github.com:user/repo.git"

        while true; do
            remote_url="$(printf "%s\n" "$dummy" | rofi_cmd "Git repo" "$dummy")"

            [[ -z "$remote_url" ]] && return 1
            [[ "$remote_url" == "$dummy" ]] && continue 

            return 0
        done
    fi

    if pass git remote add origin "$remote_url" >/dev/null 2>&1; then
        notify-send -r 1 -t 2000 -u low "Vibranium" "Remote repository added"
        return 0
    else
        notify-send -r 2 -t 5000 -u critical "Vibranium" "Error adding remote repository"
        return 1
    fi
}

initialize_git_repo() {
    cd "$PASSWORD_STORE_DIR" || return 1
    
    if pass git init >/dev/null 2>&1; then
        local choice
        choice="$(printf "Yes\nNo" | rofi_cmd "Add a remote repository?" "")"
        
        if [[ "$choice" == "Yes" ]]; then
            if add_git_remote; then
                local push_choice
                push_choice="$(printf "Yes\nNo" | rofi_cmd "Push initial commit to remote?" "")"
                if [[ "$push_choice" == "Yes" ]]; then
                    local current_branch
                    current_branch=$(pass git rev-parse --abbrev-ref HEAD)
                    output="$(pass git push -u origin "$current_branch" 2>&1)"; ret=$?

                    if [[ $ret -ne 0 ]]; then
                        notify-send -r 2 -t 5000 -u critical "Vibranium" "Error pushing to remote: $output"
                    else
                        notify-send -r 1 -t 2000 -u low "Vibranium" "Pushed to remote successfully"
                    fi
                fi
            else
                rm -rf "./.git"
            fi
        else
            rm -rf "./.git"
            return 0
        fi
        
        return 0
    else
        notify-send -r 2 -t 5000 -u critical "Vibranium" "Error initializing local git repository"
        return 1
    fi
}

search_passwords() {
    while true; do
        local all_passwords=()
        mapfile -t all_passwords < <(
            find "$PASSWORD_STORE_DIR" -type f -name "*.gpg" ! -path "./.git/*" -printf "%P\n" | sed 's/\.gpg$//' | sort -V 
        )
        
        local row_key="search"
        local selected_row="${last_selected_row[$row_key]:-0}"
        local chosen_full
        chosen_full="$(printf "%s\n" "${all_passwords[@]}" | rofi_cmd "Search" "" -selected-row "$selected_row")"
        [[ -z "$chosen_full" ]] && return 1

        # Save the selected index
        for i in "${!all_passwords[@]}"; do
            if [[ "${all_passwords[$i]}" == "$chosen_full" ]]; then
                last_selected_row[$row_key]="$i"
                break
            fi
        done
        
        while true; do
            action "$chosen_full"
            action_ret=$?
            if [[ $action_ret -eq 0 ]]; then
                exit 0
            elif [[ $action_ret -eq 2 ]]; then
                break  # Back to search, keep current position
            elif [[ $action_ret -eq 3 ]]; then
                # File was deleted, rebuild the list
                break  # This will trigger the outer loop to rebuild
            else
                continue
            fi
        done
    done
}

# Main loop
while true; do
    if ! is_password_store_initialized; then
        OPTIONS=("Create a password store")
        row_key="main_init"
        selected_row="${last_selected_row[$row_key]:-0}"
        OPTION_CHOSEN="$(printf "%s\n" "${OPTIONS[@]}" | rofi_cmd "Password manager" "" -selected-row "$selected_row")"
        [[ -z "$OPTION_CHOSEN" ]] && exit 0
        
        for i in "${!OPTIONS[@]}"; do
            if [[ "${OPTIONS[$i]}" == "$OPTION_CHOSEN" ]]; then
                last_selected_row[$row_key]="$i"
                break
            fi
        done
        
        case "$OPTION_CHOSEN" in
            "Create a password store")
                initialize_password_store || continue
                ;;
        esac
        continue
    fi
    
    OPTIONS=("Create password")
    if has_password_entries; then
        OPTIONS=("Open Passwords" "Create password" "Search passwords")
    fi
    
    if is_git_repo; then
        OPTIONS+=(
            "<span foreground='${P_YELLOW}'>[GIT]</span> Push to remote"
            "<span foreground='${P_YELLOW}'>[GIT]</span> Pull from remote"
        )
    else
        OPTIONS+=("<span foreground='${P_YELLOW}'>[GIT]</span> Init git repo")
    fi
    
    row_key="main"
    selected_row="${last_selected_row[$row_key]:-0}"
    OPTION_CHOSEN="$(printf "%s\n" "${OPTIONS[@]}" | rofi_cmd "Search" "" -selected-row "$selected_row")"
    [[ -z "$OPTION_CHOSEN" ]] && exit 0

    for i in "${!OPTIONS[@]}"; do
        if [[ "${OPTIONS[$i]}" == "$OPTION_CHOSEN" ]]; then
            last_selected_row[$row_key]="$i"
            break
        fi
    done

    case "$OPTION_CHOSEN" in
        "Open Passwords")
            pick_password_path ""
            action_ret=$?
            if [[ $action_ret -eq 0 ]]; then
                exit 0
            fi
            ;;
        "Search passwords")
            search_passwords
            ;;
        "Create password")
            location="$(pick_location)" || continue
            name="$(printf "" | rofi_cmd "Password name" "$dummy" -theme-str 'window{width: 40%;}')" || continue
            if [[ "$name" == "$dummy" ]] || [[ -z "$name" ]]; then
                continue
            fi
            if [[ -z "$location" ]]; then
                pass_path="$name"
            else
                pass_path="$location/$name"
            fi

            safe_pass_path="$(escape_for_shell_arg "$pass_path")"
            if pass generate -c "$safe_pass_path" >/dev/null; then
                notify-send -r 1 "Vibranium" "Password generated and copied to clipboard"
                if is_git_repo; then
                    (
                        output="$(git_push_with_upstream_check 2>&1)"; push_ret=$?
                        if [[ $push_ret -ne 0 ]]; then
                            notify-send -r 2 -t 5000 -u critical "Vibranium" "Error pushing to remote: $output"
                        else
                            notify-send -r 1 -t 1500 -u low "Vibranium" "Pushed to remote"
                        fi
                    ) &
                fi
                exit 0
            else
                continue
            fi
            ;;
        *"Init git repo")
            initialize_git_repo
            ;;
        *"Push to remote")
            if ! has_git_remote; then
                choice="$(printf "Yes\nNo\n" | rofi_cmd "No remote repository. Add one now?" "")"
                if [[ "$choice" == "Yes" ]]; then
                    if ! add_git_remote; then
                        continue
                    fi
                else
                    continue
                fi
            fi

            output="$(git_push_with_upstream_check 2>&1)"; ret=$?
            if [[ $ret -ne 0 ]]; then
                notify-send -r 2 -t 5000 -u critical "Vibranium" "Error pushing to remote: $output"
                exit 1
            elif [[ "$output" == "Everything up-to-date" ]]; then
                notify-send -r 1 -t 1500 -u low "Vibranium" "Already up to date"
                exit 0
            else
                notify-send -r 1 -t 1500 -u low "Vibranium" "Pushed to remote successfully"
                exit 0
            fi
            ;;
        *"Pull from remote")
            if ! has_git_remote; then
                choice="$(printf "Yes\nNo\n" | rofi_cmd "No remote repository. Add one now?" "")"
                if [[ "$choice" == "Yes" ]]; then
                    if ! add_git_remote; then
                        continue
                    fi
                else
                    continue
                fi
            fi

            output="$(pass git pull 2>&1)"; ret=$?
            if [[ $ret -ne 0 ]]; then
                notify-send -r 2 -t 5000 -u critical "Vibranium" "Error pulling from remote: $output"
                exit 1
            elif [[ "$output" == "Already up to date." ]]; then
                notify-send -r 1 -t 1500 -u low "Vibranium" "Already up to date"
                exit 0
            else
                notify-send -r 1 -t 1500 -u low "Vibranium" "Pulled from remote successfully"
                exit 0
            fi
            ;;
    esac
done
